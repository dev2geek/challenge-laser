<!doctype html>
<html lang="zh-cn">
    <head>
        <meta charset="UTF-8">
        <title>Step 1</title>
        <link href="./step1.css" media="all" rel="stylesheet" type="text/css" />
    </head>
    <body>
        <h1>Yes, Chrome Only</h1>
        <div class="box"></div>
        
        <div class="dot" id="source">
            <span class="niddle"></span>
        </div>

        <div class="dot" id="sacrifice">
            <span class="niddle"></span>
        </div>

        <div class="dot" id="pharaoh" style="display: none;">
            <span class="niddle"></span>
        </div>

        <div class="mirror" id="ma">
            <span class="niddle left-most"></span>
            <span class="niddle right-most"></span>
        </div>
        
        <div class="mirror" id="mb">
            <span class="niddle left-most"></span>
            <span class="niddle right-most"></span>
        </div>
    </body>
    <script src="./lib/jquery-1.9.1.min.js" type="text/javascript" charset="utf-8"></script>
    <script src="./step1.js" type="text/javascript" charset="utf-8"></script>
    <script>
        $(function() {
            // 从光源发出的第一束激光
            function draw() {
                lines = [];

                $(".line").remove();

                var ma_1 = $("#ma .left-most").offset(),
                    ma_2 = $("#ma .right-most").offset(),
                    mb_1 = $("#mb .left-most").offset(),
                    mb_2 = $("#mb .right-most").offset(),
                    ma_x1 = ma_1.left,
                    ma_y1 = ma_1.top,
                    ma_x2 = ma_2.left,
                    ma_y2 = ma_2.top,
                    mb_x1 = mb_1.left,
                    mb_y1 = mb_1.top,
                    mb_x2 = mb_2.left,
                    mb_y2 = mb_2.top,
                    distance_1,
                    distance_2,
                    cross_over_1 = getCrossOver2pAp(ma_x1, ma_y1, ma_x2, ma_y2, source_x, source_y, 0),
                    cross_over_2 = getCrossOver2pAp(mb_x1, mb_y1, mb_x2, mb_y2, source_x, source_y, 0),
                    currentMirror,
                    nextMirror,
                    currentCrossOver;

                if (!!cross_over_1 && !!cross_over_2) {
                    distance_1 = getDistance(source_x, source_y, cross_over_1.x, cross_over_1.y);
                    distance_2 = getDistance(source_x, source_y, cross_over_2.x, cross_over_2.y);

                    if (distance_1 < distance_2) {
                        drawLine2p(".box", source_x, source_y, cross_over_1.x, cross_over_1.y);
                        currentMirror = {
                            start: {
                                x: ma_x1,
                                y: ma_y1
                            },
                            end: {
                                x: ma_x2,
                                y: ma_y2
                            },
                            line_equa: (getLineFuncBy2Po(ma_x1, ma_y1, ma_x2, ma_y2))()
                        };
                        currentCrossOver = cross_over_1;
                        nextMirror = {
                            start: {
                                x: mb_x1,
                                y: mb_y1
                            },
                            end: {
                                x: mb_x2,
                                y: mb_y2
                            },
                            line_equa: (getLineFuncBy2Po(mb_x1, mb_y1, mb_x2, mb_y2))()
                        };
                    } else {
                        drawLine2p(".box", source_x, source_y, cross_over_2.x, cross_over_2.y);
                        currentMirror = {
                            start: {
                                x: mb_x1,
                                y: mb_y1
                            },
                            end: {
                                x: mb_x2,
                                y: mb_y2
                            },
                            line_equa: (getLineFuncBy2Po(mb_x1, mb_y1, mb_x2, mb_y2))()
                        };
                        currentCrossOver = cross_over_2;
                        nextMirror = {
                            start: {
                                x: ma_x1,
                                y: ma_y1
                            },
                            end: {
                                x: ma_x2,
                                y: ma_y2
                            },
                            line_equa: (getLineFuncBy2Po(ma_x1, ma_y1, ma_x2, ma_y2))()
                        };
                    }
                } else if(!!cross_over_1) {
                    drawLine2p(".box", source_x, source_y, cross_over_1.x, cross_over_1.y);
                    currentMirror = {
                        start: {
                            x: ma_x1,
                            y: ma_y1
                        },
                        end: {
                            x: ma_x2,
                            y: ma_y2
                        },
                        line_equa: (getLineFuncBy2Po(ma_x1, ma_y1, ma_x2, ma_y2))()
                    };
                    currentCrossOver = cross_over_1;
                    nextMirror = {
                        start: {
                            x: mb_x1,
                            y: mb_y1
                        },
                        end: {
                            x: mb_x2,
                            y: mb_y2
                        },
                        line_equa: (getLineFuncBy2Po(mb_x1, mb_y1, mb_x2, mb_y2))()
                    };
                } else if(!!cross_over_2) {
                    drawLine2p(".box", source_x, source_y, cross_over_2.x, cross_over_2.y);
                    currentMirror = {
                        start: {
                            x: mb_x1,
                            y: mb_y1
                        },
                        end: {
                            x: mb_x2,
                            y: mb_y2
                        },
                        line_equa: (getLineFuncBy2Po(mb_x1, mb_y1, mb_x2, mb_y2))()
                    };
                    currentCrossOver = cross_over_2;
                    nextMirror = {
                        start: {
                            x: ma_x1,
                            y: ma_y1
                        },
                        end: {
                            x: ma_x2,
                            y: ma_y2
                        },
                        line_equa: (getLineFuncBy2Po(ma_x1, ma_y1, ma_x2, ma_y2))()
                    };
                }
                if (!currentMirror) {
                    drawLinepa(".box", source_x, source_y, 0);
                } else {
                    var mirror_p = getMirrorPoint(source_x, source_y, currentMirror.line_equa);

                    var angle = getAngleBy2p(currentCrossOver.x, currentCrossOver.y, mirror_p.x, mirror_p.y);
                    
                    //drawLinepa(".box", currentCrossOver.x, currentCrossOver.y, angle);
                    drawRecursive(currentMirror, nextMirror, currentCrossOver, angle, 1);


                }
            }
            
            // 从某镜面反射出的激光，以及它被另一镜面反射，以及可能存在的递归反射的绘制，最多反射10次
            function drawRecursive(current, next, source, angle, times) {
                if (times++ <= MAX_REFLECTION) {
                    
                    var cross = getCrossOver2pAp(next.start.x, next.start.y, next.end.x, next.end.y, source.x, source.y, angle),
                        line_func, line;

                    if (!cross) {
                        line_func = getLineFuncByPoAn(source.x, source.y, angle);
                        // if (line_func(sacrifice)) {
                        //     $("#pharaoh").css("display", "block");
                        // }

                        // if (line_func(pharaoh)) {
                        //     $("#sacrifice").css("display", "block");
                        // }
                        // 
                        if ($("#pharaoh").css("display") === "none") {
                            if (line_func(sacrifice)) {
                                $("#pharaoh").css("display", "block");
                            }    
                        }

                        lines.push(line_func());

                        drawLinepa(".box", source.x, source.y, angle);
                    } else {
                        line_func = getLineFuncBy2Po(source.x, source.y, cross.x, cross.y);
                        
                        if ($("#pharaoh").css("display") === "none") {
                            if (line_func(sacrifice)) {
                                $("#pharaoh").css("display", "block");
                            }    
                        }
                        

                        // if (line_func(pharaoh)) {
                        //     $("#sacrifice").css("display", "block");
                        // }

                        lines.push(line_func());

                        drawLine2p(".box", source.x, source.y, cross.x, cross.y);

                        var mirror_p = getMirrorPoint(source.x, source.y, next.line_equa),
                            angle = getAngleBy2p(cross.x, cross.y, mirror_p.x, mirror_p.y);

                        
                        drawRecursive(next, current, cross, angle, times);


                    }
                } 
            }

            setInterval(draw, 100);
            //draw();
        });
    </script>
</html>